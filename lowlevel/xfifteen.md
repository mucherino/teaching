
# Multiplying several 4-bit integers by 15

The task of multiplying a certain (large) number of
positive integers by the constant 15 can be optimized
at two levels. Both optimizations can be coded in C, 
but a closer look at the assembly code generated by
[```clang```](https://clang.llvm.org) will subsequently
allow us to optimize the performances of our program
even farther.

## C version

First of all, we can notice that the binary multiplication
between two bit strings can be written as:

	      0 1 0 1 *   (aka 5)
	      0 1 1 0 =   (aka 6)
	      -------
	      0 0 0 0 +
	    0 1 0 1   +
	  0 1 0 1     +
	0 0 0 0       =
	-------------
	0 0 1 1 1 1 0    (aka 30)

Basically, when the involved integers are formed by 4 bits
each, the multiplication can be performed by 3 shifts and 3 
integer sums. However, since one of our two numbers is a known
constant (15), a more efficient procedure (involving fewer
computations) can be proposed. This alternative procedure is 
based on the fact that we can write

$$
15 \times x = 2 \times (4 \times x + x) + (4 \times x + x) ,
$$

and on the fact that multiplications by power of 2 can be 
performed by simple bit shifts. If $x$ is the *one* integer 
number to be multiplied by 15, the following code is equivalent 
to ```15*x```:

	unsigned long computation(unsigned long x)
	{
	   unsigned long four_x = x << 2;  // one shift
	   unsigned long five_x = four_x + x;  // one sum
	   unsigned long ten_x = five_x << 1;  // another shift
	   return ten_x + five_x;  // another sum
	};

We can remark that this code is able to perform the multiplication 
by executing only 2 shifts and 2 integer sums (instead of 3 shifts 
and 3 integer sums). This is [C file](./xfifteen-computation.c).

There is also another way to optimize (we keep working in C at the 
moment). We can remark that the involved variables are of type 
```unsigned long```, corresponding to integers formed by 64 bits. 
Since our integers are 4-bit long, we could potentially include 16 
of our integers in only one variable of this type. When performing 
the bit shifts and sums, however, additional bits will be necessary 
for the representation of the results. For this reason, we can rather 
consider to reserve a 8-bit chunk for each of the original 4-bit integers,
so that the results of each multiplicatio by 15 will be able to fit in 
the 8 bits consisting of each chunk.

This is the [main C function](./xfifteen-main.c). Notice that this
[C function](./xfifteen-computation.c) performs the desired calculations
even when the input ```unsigned long``` contains eight 8-bit chunks each 
containing the original 4-bit integers (and not a only a single integer).

## Assembly version

We have learned in the [previous lesson](./myabs.md) how compile C code 
in llvm and assembly with [```clang```](https://clang.llvm.org). Please do 
this now for this [C function](./xfifteen-computation.c), and try to read 
the generated codes. Then, look at the following assembly code, which is 
supposed to make exactly the same job as the C function, but it is quite
different from the code generated by the compiler:

	movq    %rdi, %rcx    # rcx = x
	movq    %rdi, %rbx    # rbx = x
	shlq    $2, %rbx      # rbx = 4x
	addq    %rcx, %rbx    # rbx = 5x
	movq    %rbx, %rax    # rax = 5x
	shlq    $1, %rax      # rax = 10x
	addq    %rbx, %rax    # rax = 15x
	retq

Notice that there is no communication at all with the central memory in 
this handwritten version, and that the used *generic* registers are chosen 
in opposite order w.r.t. the common practice: this allows us to have directly
the final result in the ```rax``` register, exactly where we are supposed to 
place it before ending (avoiding in this way an extra call to ```movq```).

The complete handwritten assembly code is in this 
[asm file](./xfifteen-handwritten.asm). If you feel confident 
with this example, please try to answer an additional question: 
what if the original C function were passing the input argument through
a pointer? Can this fact have any impact on the assembly code (both the 
generated and handwritten ones) ?

## Performance verification

Do you think these improvements on this small code in assembly
may already allow us to observe improvements on the performances of 
our programs? Download this [main C file](./xfifteen-perf.c) and link it,
always using the [```clang```](https://clang.llvm.org) compiler,
with either the compiled [C file](./xfifteen-computation.c),
or the compiled [assembly handwritten file](./fifteen-handwritten.asm).
Then run the executable in both situations. 
Do you see any variations on the performances?

## Credits

This lesson was inspired by the following MIT open course available 
on YouTube: [What compilers can and cannot do](https://www.youtube.com/watch?v=ulJm7_aTiQM).

## Links

* [Back to low-level programming](./README.md)
* [Back to main repository page](../README.md)

